# 设计模式面试题

## 接口是什么？为什么要使用接口而不是直接使用具体类？

- 接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。

## java中，抽象类与接口之间有什么区别？

1.一个类可以实现多个接口 ，但却只能继承最多一个抽象类。

2.抽象类可以包含具体的方法 ， 接口的所有方法都是抽象的。

3.抽象类可以声明和使用字段 ，接口则不能，但接口可以创建静态的final常量。

4.接口的方法都是public的，抽象类的方法可以是public，protected，private或者默认的package；

5.抽象类可以定义构造函数，接口却不能。

## 请列举出在JDK中几个常用的设计模式

- 单例模式用于Runtime、Calendar和其他的一些类中
- 工厂模式被用于各种不可变的类如Boolean、像Boolean.valueOf方法
- 观察者模式被用于swing和很多的时间监听中
- 装饰器模式被用于多个java IO类。

## 什么是设计模式？

- 设计模式是世界上各种各样程序员用来解决特定设计问题的尝试和测试的方法。设计模式是代码可用性的延伸。

## 你是否在你的代码里面使用过任何设计模式？

- 1)**工厂模式**：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。
- 2)**代理模式**：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache 代理、防火墙代理、同步化代理、智能引用代理。
- 3)**适配器模式**：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。
- 4)**模板方法模式**：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。
- 除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections 工具类里面的 synchronizedXXX 方法把一个线程不安全的容器变成线程安全容器就是对装潢模式的应用，而 Java IO 里面的过滤流（有的翻译成处理流）也是应用装潢模式的经典例子）等，反正原则就是拣自己最熟悉的用得最多的作答，以免言多必失。

## 解释下什么是观察者模式？

 - 观察者模式是基于对象的状态变化和观察者的通讯，以便他们作出相应的操作。简单的例子就是一个天气系统，当天气变化时必须在展示给公众的视图中进行反映。这个视图对象是一个主体，而不同的视图是观察者。

## 为什么要用工厂模式 

- (1) 解耦 ：把对象的创建和使用的过程分开
- (2)降低代码重复: 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。
- (3) 降低维护成本 ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建对象B的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。

## 使用工厂模式最主要的好处是什么

- 工厂模式的最大好处是增加了创建对象时的封装层次。
- 如果你使用工厂来创建对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任何修改。1

## 工厂模式与抽象工厂模式的区别

- 工厂模式：定义一个用于创建对象的借口，让子类决定实例化哪一个类
- 抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类
- 如果产品单一，最合适用工厂模式，但是如果有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。再通俗深化理解下：工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。

<table style="width: 754px" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="362">
<p>工厂方法模式</p>


  </td>
<td valign="top" width="390">
<p>抽象工厂模式</p>


  </td>


 </tr>
<tr>
<td valign="top" width="362">
<p align="left">针对的是一个产品等级结构</p>


  </td>
<td valign="top" width="390">
<p align="left">针对的是面向多个产品等级结构</p>


  </td>


 </tr>
<tr>
<td valign="top" width="362">
<p align="left">一个抽象产品类</p>


  </td>
<td valign="top" width="390">
<p align="left">多个抽象产品类</p>


  </td>


 </tr>
<tr>
<td valign="top" width="362">
<p align="left">可以派生出多个具体产品类</p>


  </td>
<td valign="top" width="390">
<p align="left">每个抽象产品类可以派生出多个具体产品类</p>


  </td>


 </tr>
<tr>
<td valign="top" width="362">
<p align="left">一个抽象工厂类，可以派生出多个具体工厂类</p>


  </td>
<td valign="top" width="390">
<p align="left">一个抽象工厂类，可以派生出多个具体工厂类</p>


  </td>


 </tr>
<tr>
<td valign="top" width="362">
<p align="left">每个具体工厂类只能创建一个具体产品类的实例</p>


  </td>
<td valign="top" width="390">
<p align="left">每个具体工厂类可以创建多个具体产品类的实例</p>


  </td>


 </tr>


</tbody>

</table>

## 举一个用Java 实现的装饰模式(decorator design pattern)？

- 装饰模式增加强了单个对象的能力。Java IO 到处都使用了装饰模式，典型例子就是Buffered 系列类如BufferedReader和BufferedWriter，它们增强了Reader和Writer对象，以实现提升性能的 Buffer 层次的读取和写入。

## 适配器模式是什么？什么时候使用？

- 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。

## 适配器模式与装饰器模式有什么区别？

- 虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。

- 装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者模提供了比继承更有弹性的替代方案。 
通俗的解释：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。

- 适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 
适配器模式有三种：类的适配器模式、对象的适配器模式、接口的适配器模式。 
通俗的说法：适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。

## 什么是代理模式

- 代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。

## 适配器模式和代理模式之间有什么不同？

- 这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。

## 什么是模板方法模式

- 模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用 Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方法就是众所周知的模板方法。

## 符合开闭原则的设计模式的例子

- 开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是 Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。

## 举出一个例子，在这种情况你会更倾向于使用抽象类，而不是接口

这是很常用但又是很难回答的设计面试问题。接口和抽象类都遵循”面向接口而不是实现编码”设计原则，它可以增加代码的灵活性，可以适应不断变化的需求。下面有几个点可以帮助你回答这个问题：

在一些对时间要求比较高的应用中，倾向于使用抽象类，它会比接口稍快一点。
如果希望把一系列行为都规范在类继承层次内，并且可以更好地在同一个地方进行编码，那么抽象类是一个更好的选择。有时，接口和抽象类可以一起使用，接口中定义函数，而在抽象类中定义默认的实现。

## 设计一个ATM机


我们所有人都使用ATM(自动柜员机)。想想你会怎么设计一个ATM？就设计金融系统来说，必须知道它们应该在任何情况下都能够如期工作。不管是断电还是其他情况，ATM应该保持 正确的状态（事务） , 想想 加锁（locking）、事务（transaction）、错误条件（error condition）、边界条件（boundary condition） 等等。尽管你不能想到具体的设计，但如果你可以指出非功能性需求，提出一些问题，想到关于边界条件，这些都会是很好的一步。



